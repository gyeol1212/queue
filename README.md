큐에 대한 이해
==============
큐(queue)란?
--------
큐(queue)란, 선입선출(先入先出, First In First Out; FIFO)의 자료구조를 의미한다. 간단하게 설명해서 먼저 들어온 데이터가 먼저 나가는 자료 구조이다. 데이터가 들어오는 위치는 후단(Rear 또는 Back이라고 한다.)에 있고, 데이터가 나가는 위치는 전단(Front라고 한다.)에 있다. 일반적으로 입력은 Enqueue, 출력은 Dequeue라 한다. 

구현 방법
------
#### 1) 직선 큐
미리 배열의 크기를 지정한 뒤, 들어오는 데이터를 순서대로 나열해, 전단부터 차례차례 내보낸다.
하지만 이러한 직선큐의 치명적인 단점은 출력(Dequeue)를 한 이후, 전단의 데이터를 내보내고 나면, 배열 내의 모든 요소들을 한칸씩 앞으로 옮겨주어야 한다. 큐의 용량이 커진다면 이러한 연산은 너무 커질 것이다.
이를 보완하기 위해, 요소들을 한칸씩 옮기는 것이 아니라, 전단과 후단의 위치를 조정하는 방법도 있다. 하지만 이렇게 할 경우 연산을 거듭할 수록 전단의 위치가 점점 뒤로 밀리면서, 후단에 데이터를 입력할 공간이 줄어들 것이다.


#### 2) 순환 큐
앞서 언급한 직선큐의 단점을 보완하기 위해 순환큐를 사용한다. 순환큐란 배열의 처음과 끝을 이어놓은 구조이다. 이렇게 할 경우 후단에 데이터를 넣을 공간이 줄어드는 것도 해결 할 수 있고, 데이터를 한칸씩 옮길 필요도 없다. 하지만 원형이기 때문에, 데이터가 없을 떄와 데이터가 꽉차있을 때 모두 전단과 후단의 위치가 같게 된다. 이를 해결하기 위해 Dummy공간을 확보하여, 데이터가 없을 때는 전단과 후단이 같은 위치에, 데이터가 꽉찰 경우 후단이 전단보다 1 작은 값을 가지게 된다. 
단점 : 배열을 사용하기 때문에 용량을 미리 지정해야 하는 한계, 전단과 후단의 위치를 이리저리 옮겨야 하기 때문에 구현이 복잡.

#### 3) 링크드 큐
스택에서 공부한 연결리스트 스택과 같은 원리이며, 데이터가 들어가는 방향만 차이가 있다. 삽입 연산이 실행되면 리스트의 말미에 노드가 추가되고, 기존 후단 노드의 다음 노드가 새로운 후단 노드가 된다. 반대로 제거 연산이 실행되면 리스트의 처음에 노드가 추가되고, 기존 전단 노드의 이전 노드가 새로운 전단 노드가 된다. 

용도
------
작업한 데이터를 순서대로 실행 또는 사용하기 위해 대기시키는 경우 광범위하게 사용 가능하다. 
순서대로 처리해야 되는 경우 큐를, 최근의 데이터부터 처리해야 하는 경우 스택을 사용한다고 생각하면 될 것이다. 

백준 10845번 풀이
--------
백준 10845번 문제를 원시적으로 풀 때는 파이썬의 list를 이용.
파이썬에서는 append() 함수를 이용해서 동적 할당이 가능하기 때문에 배열을 사용하더라도 미리 배열의 크기를 선언할 필요없이 아래와 같이 구현.
또한 배열의 첫 인자를 return하고 삭제하기 위해 pop(0)함수를 이용해서 구현
```py
queue = []
queue.append(data)
print(queue.pop(0))
```
파이썬의 큐 모듈
----------
파이썬에서는 queue 모듈을 통해서 큐, 스택, 우선순위큐 클래스를 제공
```py
import queue
queue.Queue(maxsize) # 큐 객체를 생성
# stack = queue.LifoQueue(maxsize) 스택 객체를 생성
#queue.PriorityQueue(maxsize)  우선순위 큐 객체를 생성

q = queue.Queue()

# 각각의 클래스는 아래의 매소드를 보유
q.qsize() # 객체에 입력된 데이터의 갯수
q.put("data") # 객체에 "data"라는 아이템 입력
q.get() # 객체의 전단 아이템을 리턴후 삭제 (꺼낼 아이템이 없을 경우 무한 대기 상태에 빠짐)
q.get_nowait() # 데이터가 없는 경우의 예외를 처리하기 위해. 데이터가 없는 경우 queue.Empty 예외 발생
q.put_nowait("data2") # 큐 내에 더이상 아이템을 저장할 공간이 없을 경우 queue.Full 예외 발생
